# AWS 인스턴스 배포 자동화 워크플로우 (ALB + Bastion Host 아키텍처)
# SSH 터널링을 통한 Private Instance 배포
# 
# 실행 방법:
# 1. 수동 실행: GitHub Actions에서 "Run workflow"로 실행 시 Bastion Host IP와 도메인 입력
# 2. 자동 실행: main 브랜치에 push/merge 시 자동 배포 (BASTION_IP, DOMAIN_NAME secret 필요)
# 3. 테스트 실행: feature/cd 브랜치에 push 시 테스트용 자동 실행
#
# 아키텍처:
# - Public Subnet: ALB, NAT Gateway, Bastion Host
# - Private Subnet: Service Instance (Frontend, Backend, AI, DB)
# - Route53 + ACM으로 도메인 인증서 관리
# - ALB로 Frontend(/) 와 API(/api) 라우팅 분리

name: CD Pipeline

on:
  # 수동 실행 (Bastion Host IP와 도메인 입력)
  workflow_dispatch:
    inputs:
      bastion_ip:
        description: 'Bastion Host Public IP Address (예: 13.124.123.45)'
        required: true
        type: string
      domain_name:
        description: 'Service Domain Name (예: api.example.com)'
        required: true
        type: string
      service_instance_ip:
        description: 'Private Service Instance IP (예: 10.0.3.10)'
        required: true
        type: string
  
  # main 브랜치에 push 시 자동 배포
  push:
    branches:
      - feature/cd
  
  # main 브랜치로 PR이 merge될 때 자동 배포
  pull_request:
    branches:
      - main
    types:
      - closed

permissions:
  contents: read
  pull-requests: write

jobs:
  deploy:
    runs-on: ubuntu-latest
    # PR이 merged된 경우나 직접 push된 경우에만 실행
    if: github.event_name == 'workflow_dispatch' || github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    
    env:
      # 환경변수 설정: workflow_dispatch일 때는 입력받은 값 사용, 자동 실행시엔 secrets 사용
      BASTION_IP: ${{ github.event.inputs.bastion_ip || secrets.BASTION_IP }}
      DOMAIN_NAME: ${{ github.event.inputs.domain_name || secrets.DOMAIN_NAME }}
      SERVICE_INSTANCE_IP: ${{ github.event.inputs.service_instance_ip || secrets.SERVICE_INSTANCE_IP }}
    
    steps:
    # 소스 코드 체크아웃
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.PAT_TOKEN }}

    # AWS 인증 설정
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    # ECR 로그인
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    # 기존 ECR 이미지 삭제 (용량 절약)
    - name: Delete existing ECR images (if any)
      run: |
        echo "Deleting existing images..."
        aws ecr batch-delete-image --repository-name mt-frontend --image-ids imageTag=latest --region ${{ secrets.AWS_REGION }} || true
        aws ecr batch-delete-image --repository-name mt-backend --image-ids imageTag=latest --region ${{ secrets.AWS_REGION }} || true
        aws ecr batch-delete-image --repository-name mt-ai --image-ids imageTag=latest --region ${{ secrets.AWS_REGION }} || true
        aws ecr batch-delete-image --repository-name mt-db --image-ids imageTag=latest --region ${{ secrets.AWS_REGION }} || true

    # 프론트엔드 이미지 빌드 및 푸시 (도메인 기반 URL 주입)
    - name: Build and push Frontend image
      run: |
        echo "Building Frontend with domain: ${{ env.DOMAIN_NAME }}"
        docker build \
          --build-arg NEXT_PUBLIC_BACKEND_URL=https://${{ env.DOMAIN_NAME }} \
          -t ${{ secrets.ECR_REGISTRY }}/mt-frontend:latest \
          ./frontend
        docker push ${{ secrets.ECR_REGISTRY }}/mt-frontend:latest

    # 백엔드 이미지 빌드 및 푸시
    - name: Build and push Backend image
      run: |
        echo "Building Backend..."
        docker build -t ${{ secrets.ECR_REGISTRY }}/mt-backend:latest ./backend
        docker push ${{ secrets.ECR_REGISTRY }}/mt-backend:latest

    # AI 서비스 이미지 빌드 및 푸시
    - name: Build and push AI image
      run: |
        echo "Building AI service..."
        docker build -t ${{ secrets.ECR_REGISTRY }}/mt-ai:latest ./ai
        docker push ${{ secrets.ECR_REGISTRY }}/mt-ai:latest

    # 데이터베이스 이미지 빌드 및 푸시
    - name: Build and push DB image
      run: |
        echo "Building Database..."
        docker build -t ${{ secrets.ECR_REGISTRY }}/mt-db:latest ./db
        docker push ${{ secrets.ECR_REGISTRY }}/mt-db:latest

    # docker-compose.production.yml에 환경변수 주입
    - name: Configure docker-compose with secrets
      run: |
        # GitHub Secrets을 사용하여 환경변수 치환
        # Frontend 환경변수 (ALB를 통한 도메인 기반 접근)
        sed -i "s|\${NEXT_PUBLIC_BACKEND_URL}|https://${{ env.DOMAIN_NAME }}|g" docker-compose.production.yml
        
        # Backend 환경변수  
        sed -i "s|\${BACKEND_PORT}|${{ secrets.BACKEND_PORT }}|g" docker-compose.production.yml
        sed -i "s|\${DB_NAME}|${{ secrets.DB_NAME }}|g" docker-compose.production.yml
        sed -i "s|\${DB_USER}|${{ secrets.DB_USER }}|g" docker-compose.production.yml
        sed -i "s|\${DB_PASSWORD}|${{ secrets.DB_PASSWORD }}|g" docker-compose.production.yml
        sed -i "s|\${JWT_SECRET_KEY}|${{ secrets.JWT_SECRET_KEY }}|g" docker-compose.production.yml
        sed -i "s|\${GOOGLE_CLIENT_ID}|${{ secrets.GOOGLE_CLIENT_ID }}|g" docker-compose.production.yml
        sed -i "s|\${GOOGLE_CLIENT_SECRET}|${{ secrets.GOOGLE_CLIENT_SECRET }}|g" docker-compose.production.yml
        sed -i "s|\${KAKAO_CLIENT_ID}|${{ secrets.KAKAO_CLIENT_ID }}|g" docker-compose.production.yml
        sed -i "s|\${KAKAO_CLIENT_SECRET}|${{ secrets.KAKAO_CLIENT_SECRET }}|g" docker-compose.production.yml
        sed -i "s|\${NAVER_CLIENT_ID}|${{ secrets.NAVER_CLIENT_ID }}|g" docker-compose.production.yml
        sed -i "s|\${NAVER_CLIENT_SECRET}|${{ secrets.NAVER_CLIENT_SECRET }}|g" docker-compose.production.yml
        sed -i "s|\${AWS_ACCESS_KEY_ID}|${{ secrets.AWS_ACCESS_KEY_ID }}|g" docker-compose.production.yml
        sed -i "s|\${AWS_SECRET_ACCESS_KEY}|${{ secrets.AWS_SECRET_ACCESS_KEY }}|g" docker-compose.production.yml
        sed -i "s|\${AWS_S3_REGION}|${{ secrets.AWS_S3_REGION }}|g" docker-compose.production.yml
        sed -i "s|\${AWS_S3_BUCKET_NAME}|${{ secrets.AWS_S3_BUCKET_NAME }}|g" docker-compose.production.yml
        sed -i "s|\${AI_SERVICE_URL}|${{ secrets.AI_SERVICE_URL }}|g" docker-compose.production.yml
        sed -i "s|\${TOSS_SECRET_KEY}|${{ secrets.TOSS_SECRET_KEY }}|g" docker-compose.production.yml
        sed -i "s|\${NEXT_PUBLIC_TOSS_CLIENT_KEY}|${{ secrets.NEXT_PUBLIC_TOSS_CLIENT_KEY }}|g" docker-compose.production.yml
        sed -i "s|\${NAVER_API_CLIENT_ID}|${{ secrets.NAVER_API_CLIENT_ID }}|g" docker-compose.production.yml
        sed -i "s|\${NAVER_API_CLIENT_SECRET}|${{ secrets.NAVER_API_CLIENT_SECRET }}|g" docker-compose.production.yml
        
        # AI 서비스 환경변수
        sed -i "s|\${DB_PORT}|${{ secrets.DB_PORT }}|g" docker-compose.production.yml
        sed -i "s|\${OPENAI_API_KEY}|${{ secrets.OPENAI_API_KEY }}|g" docker-compose.production.yml
        sed -i "s|\${OPENAI_MODEL}|${{ secrets.OPENAI_MODEL }}|g" docker-compose.production.yml
        sed -i "s|\${OPENAI_IMAGE_MODEL}|${{ secrets.OPENAI_IMAGE_MODEL }}|g" docker-compose.production.yml
        sed -i "s|\${OPENAI_BREEDING_MODEL}|${{ secrets.OPENAI_BREEDING_MODEL }}|g" docker-compose.production.yml
        sed -i "s|\${EMBEDDING_MODEL_NAME}|${{ secrets.EMBEDDING_MODEL_NAME }}|g" docker-compose.production.yml
        sed -i "s|\${VECTORSTORE_COLLECTION_NAME}|${{ secrets.VECTORSTORE_COLLECTION_NAME }}|g" docker-compose.production.yml
        sed -i "s|\${VECTORSTORE_DISTANCE_STRATEGY}|${{ secrets.VECTORSTORE_DISTANCE_STRATEGY }}|g" docker-compose.production.yml
        sed -i "s|\${VECTORSTORE_SEARCH_LIMIT}|${{ secrets.VECTORSTORE_SEARCH_LIMIT }}|g" docker-compose.production.yml
        sed -i "s|\${SAMPLE_DATA_PATH}|${{ secrets.SAMPLE_DATA_PATH }}|g" docker-compose.production.yml
        sed -i "s|\${PROMPT_TEMPLATE_PATH}|${{ secrets.PROMPT_TEMPLATE_PATH }}|g" docker-compose.production.yml
        
        # OAuth2 및 Frontend URL 환경변수 (새로 추가된 변수들)
        sed -i "s|OAUTH2_REDIRECT_URI_BASE=https://meongtory.shop|OAUTH2_REDIRECT_URI_BASE=https://${{ env.DOMAIN_NAME }}|g" docker-compose.production.yml
        sed -i "s|FRONTEND_URL=https://meongtory.shop|FRONTEND_URL=https://${{ env.DOMAIN_NAME }}|g" docker-compose.production.yml
        
        echo "Configured docker-compose.production.yml with environment variables"

    # 연결 테스트 및 디버깅
    - name: Test bastion connectivity and debug
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ env.BASTION_IP }}
        username: ubuntu
        key: ${{ secrets.AWS_PEM_KEY }}
        timeout: 60s
        script: |
          echo "🔍 Debugging network connectivity from Bastion Host..."
          echo "Bastion Host Network Info:"
          ip route show | head -5
          echo ""
          
          echo "Testing connectivity to Service Instance..."
          echo "Service Instance IP: ${{ env.SERVICE_INSTANCE_IP }}"
          
          # Ping 테스트
          echo "1. Ping test:"
          ping -c 3 ${{ env.SERVICE_INSTANCE_IP }} || echo "❌ Ping failed"
          
          # Port 22 연결 테스트
          echo "2. SSH Port (22) connectivity test:"
          timeout 10 nc -zv ${{ env.SERVICE_INSTANCE_IP }} 22 || echo "❌ SSH port not accessible"
          
          # SSH 키 설정 및 간단한 연결 테스트
          echo "3. SSH connection test:"
          echo "${{ secrets.AWS_PEM_KEY }}" > /tmp/service_key.pem
          chmod 600 /tmp/service_key.pem
          
          timeout 15 ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 -i /tmp/service_key.pem ubuntu@${{ env.SERVICE_INSTANCE_IP }} 'echo "✅ SSH connection successful"' || echo "❌ SSH connection failed"
          
          rm -f /tmp/service_key.pem

    # SSH 터널링을 통한 배포 파일 전송
    - name: Deploy files via SSH tunnel
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ env.BASTION_IP }}
        username: ubuntu
        key: ${{ secrets.AWS_PEM_KEY }}
        timeout: 300s
        command_timeout: 600s
        script: |
          echo "🚀 Starting deployment via SSH tunnel..."
          
          # SSH 키 설정
          echo "${{ secrets.AWS_PEM_KEY }}" > /tmp/service_key.pem
          chmod 600 /tmp/service_key.pem
          
          # 배포 파일들을 임시 디렉토리에 생성
          mkdir -p /tmp/deployment
          
          # docker-compose.production.yml 내용을 여기서 직접 생성 (GitHub에서 전송받은 내용 기반)
          cat > /tmp/deployment/docker-compose.yml << 'COMPOSE_EOF'
          # 여기에 설정된 docker-compose.production.yml 내용이 들어갑니다
          # 실제 운영시에는 SCP로 파일을 전송하거나 다른 방법을 사용하세요
          COMPOSE_EOF
          
          echo "📁 Created deployment files in /tmp/deployment"
          
          # SSH 터널링으로 Service Instance 정리 작업
          echo "🧹 Cleaning up service instance via SSH tunnel..."
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 -i /tmp/service_key.pem ubuntu@${{ env.SERVICE_INSTANCE_IP }} << 'CLEANUP_EOF'
            echo "Starting cleanup on private service instance..."
            
            # Stop existing containers
            if [ -f /home/ubuntu/docker-compose.yml ]; then
              echo "Stopping existing containers..."
              cd /home/ubuntu
              docker-compose down || true
            fi
            
            # Clean up old files
            rm -rf /home/ubuntu/docker-compose.yml /home/ubuntu/init-db/
            
            # Clean up Docker resources
            echo "Cleaning up Docker resources..."
            docker system prune -f || true
            docker volume prune -f || true
            
            echo "✅ Cleanup completed on service instance"
          CLEANUP_EOF
          
          # 파일 전송 (SCP via SSH tunnel)
          echo "📤 Transferring deployment files to service instance..."
          scp -o StrictHostKeyChecking=no -o ConnectTimeout=30 -i /tmp/service_key.pem /tmp/deployment/docker-compose.yml ubuntu@${{ env.SERVICE_INSTANCE_IP }}:/home/ubuntu/
          
          # 서비스 시작 (SSH tunnel을 통해)
          echo "🚀 Starting services on service instance via SSH tunnel..."
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 -i /tmp/service_key.pem ubuntu@${{ env.SERVICE_INSTANCE_IP }} << 'DEPLOY_EOF'
            echo "Starting deployment on private service instance..."
            cd /home/ubuntu
            
            # Configure AWS CLI for ECR access
            echo "🔑 Configuring AWS CLI for ECR access..."
            aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
            aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
            aws configure set default.region ${{ secrets.AWS_REGION }}
            
            # Login to ECR
            echo "🔐 Logging into ECR..."
            aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.ECR_REGISTRY }}
            
            # Pull latest images
            echo "📥 Pulling latest images..."
            docker pull ${{ secrets.ECR_REGISTRY }}/mt-frontend:latest
            docker pull ${{ secrets.ECR_REGISTRY }}/mt-backend:latest
            docker pull ${{ secrets.ECR_REGISTRY }}/mt-ai:latest
            docker pull ${{ secrets.ECR_REGISTRY }}/mt-db:latest
            
            # Start services
            echo "🎯 Starting services with docker-compose..."
            docker-compose up -d
            
            # Wait a moment for services to start
            sleep 10
            
            # Show running containers
            echo "📊 Deployment completed. Running containers:"
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            # Health check
            echo "🏥 Health check:"
            curl -f http://localhost:3000/health || echo "Frontend health check failed"
            curl -f http://localhost:8080/health || echo "Backend health check failed"
            
            echo "✅ Services started successfully on service instance"
          DEPLOY_EOF
          
          # 보안을 위해 키 파일 및 임시 파일 삭제
          rm -f /tmp/service_key.pem
          rm -rf /tmp/deployment
          
          echo "🔒 Cleaned up temporary files and keys"

    # 배포 파일을 Bastion Host에 전송 (대안 방법)
    - name: Copy files to bastion host
      uses: appleboy/scp-action@v0.1.7
      with:
        host: ${{ env.BASTION_IP }}
        username: ubuntu
        key: ${{ secrets.AWS_PEM_KEY }}
        source: "docker-compose.production.yml,db/init-db"
        target: "/home/ubuntu/deployment/"

    # SSH 터널링을 통한 실제 배포 (SCP + SSH 조합)
    - name: Deploy via SSH tunnel with file transfer
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ env.BASTION_IP }}
        username: ubuntu
        key: ${{ secrets.AWS_PEM_KEY }}
        timeout: 300s
        command_timeout: 900s
        script: |
          echo "🚀 Starting deployment via SSH tunnel with file transfer..."
          
          # SSH 키 설정
          echo "${{ secrets.AWS_PEM_KEY }}" > /tmp/service_key.pem
          chmod 600 /tmp/service_key.pem
          
          # Service Instance 정리 작업
          echo "🧹 Cleaning up service instance..."
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 -o ServerAliveInterval=60 -i /tmp/service_key.pem ubuntu@${{ env.SERVICE_INSTANCE_IP }} << 'CLEANUP_EOF'
            echo "Starting cleanup on private service instance..."
            
            # Stop existing containers
            if [ -f /home/ubuntu/docker-compose.yml ]; then
              echo "Stopping existing containers..."
              cd /home/ubuntu
              docker-compose down || true
            fi
            
            # Clean up old files
            rm -rf /home/ubuntu/docker-compose.yml /home/ubuntu/init-db/
            
            # Clean up Docker resources
            echo "Cleaning up Docker resources..."
            docker system prune -f || true
            
            echo "✅ Cleanup completed"
          CLEANUP_EOF
          
          # 배포 파일 전송
          echo "📤 Transferring deployment files..."
          scp -o StrictHostKeyChecking=no -o ConnectTimeout=30 -i /tmp/service_key.pem /home/ubuntu/deployment/docker-compose.production.yml ubuntu@${{ env.SERVICE_INSTANCE_IP }}:/home/ubuntu/docker-compose.yml
          scp -o StrictHostKeyChecking=no -o ConnectTimeout=30 -r -i /tmp/service_key.pem /home/ubuntu/deployment/db/init-db ubuntu@${{ env.SERVICE_INSTANCE_IP }}:/home/ubuntu/
          
          # 서비스 배포 및 시작
          echo "🚀 Deploying services..."
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 -o ServerAliveInterval=60 -i /tmp/service_key.pem ubuntu@${{ env.SERVICE_INSTANCE_IP }} << 'DEPLOY_EOF'
            echo "Starting deployment on private service instance..."
            cd /home/ubuntu
            
            # Configure AWS CLI for ECR access
            echo "🔑 Configuring AWS CLI..."
            aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
            aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
            aws configure set default.region ${{ secrets.AWS_REGION }}
            
            # Login to ECR
            echo "🔐 Logging into ECR..."
            aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.ECR_REGISTRY }}
            
            # Pull latest images
            echo "📥 Pulling latest Docker images..."
            docker pull ${{ secrets.ECR_REGISTRY }}/mt-frontend:latest
            docker pull ${{ secrets.ECR_REGISTRY }}/mt-backend:latest
            docker pull ${{ secrets.ECR_REGISTRY }}/mt-ai:latest
            docker pull ${{ secrets.ECR_REGISTRY }}/mt-db:latest
            
            # Start services
            echo "🎯 Starting services..."
            docker-compose up -d
            
            # Wait for services to initialize
            echo "⏳ Waiting for services to start..."
            sleep 15
            
            # Health checks
            echo "🏥 Running health checks..."
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            # Test internal connectivity
            curl -f http://localhost:3000/ > /dev/null 2>&1 && echo "✅ Frontend: OK" || echo "❌ Frontend: Failed"
            curl -f http://localhost:8080/health > /dev/null 2>&1 && echo "✅ Backend: OK" || echo "❌ Backend: Failed"
            
            echo "✅ Deployment completed successfully"
          DEPLOY_EOF
          
          # 보안을 위해 키 파일 삭제
          rm -f /tmp/service_key.pem
          
          echo "🔒 Security cleanup completed"

    # 배포 완료 상태 출력
    - name: Deployment Status
      run: |
        echo "🚀 Deployment completed successfully!"
        echo "📍 Architecture: ALB + Bastion Host + Private Subnet"
        echo ""
        echo "🌐 Public Access URLs:"
        echo "  Frontend: https://${{ env.DOMAIN_NAME }}"
        echo "  API: https://${{ env.DOMAIN_NAME }}/api"
        echo ""
        echo "🔧 Infrastructure Details:"
        echo "  Bastion Host (Public): ${{ env.BASTION_IP }}"
        echo "  Service Instance (Private): ${{ env.SERVICE_INSTANCE_IP }}"
        echo "  Load Balancer: Managed by ALB"
        echo ""
        echo "📋 Services Status:"
        echo "  ✅ Frontend (Port 3000) - Routed via ALB"
        echo "  ✅ Backend (Port 8080) - Routed via ALB (/api)"  
        echo "  ✅ AI Service (Port 9000) - Internal"
        echo "  ✅ Database (Port 5432) - Internal"
        echo ""
        echo "🔐 Security:"
        echo "  ✅ SSL/TLS Certificate (ACM)"
        echo "  ✅ Private subnet isolation"
        echo "  ✅ SSH tunnel via Bastion host"